// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invocations.sql

package database

import (
	"context"
	"database/sql"
)

const createInvocation = `-- name: CreateInvocation :one
INSERT INTO invocations (
    id, function_id, deployment_id, status
) VALUES (
    ?, ?, ?, ?
) RETURNING id, function_id, deployment_id, status, duration_ms, memory_used_mb, response_size_bytes, logs, error, created_at, completed_at
`

type CreateInvocationParams struct {
	ID           string         `db:"id" json:"id"`
	FunctionID   string         `db:"function_id" json:"function_id"`
	DeploymentID sql.NullString `db:"deployment_id" json:"deployment_id"`
	Status       string         `db:"status" json:"status"`
}

func (q *Queries) CreateInvocation(ctx context.Context, arg CreateInvocationParams) (Invocation, error) {
	row := q.db.QueryRowContext(ctx, createInvocation,
		arg.ID,
		arg.FunctionID,
		arg.DeploymentID,
		arg.Status,
	)
	var i Invocation
	err := row.Scan(
		&i.ID,
		&i.FunctionID,
		&i.DeploymentID,
		&i.Status,
		&i.DurationMs,
		&i.MemoryUsedMb,
		&i.ResponseSizeBytes,
		&i.Logs,
		&i.Error,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getInvocation = `-- name: GetInvocation :one
SELECT id, function_id, deployment_id, status, duration_ms, memory_used_mb, response_size_bytes, logs, error, created_at, completed_at FROM invocations WHERE id = ?
`

func (q *Queries) GetInvocation(ctx context.Context, id string) (Invocation, error) {
	row := q.db.QueryRowContext(ctx, getInvocation, id)
	var i Invocation
	err := row.Scan(
		&i.ID,
		&i.FunctionID,
		&i.DeploymentID,
		&i.Status,
		&i.DurationMs,
		&i.MemoryUsedMb,
		&i.ResponseSizeBytes,
		&i.Logs,
		&i.Error,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getInvocationStats = `-- name: GetInvocationStats :one
SELECT 
    COUNT(*) as total_invocations,
    COUNT(CASE WHEN status = 'success' THEN 1 END) as successful_invocations,
    COUNT(CASE WHEN status = 'error' THEN 1 END) as failed_invocations,
    AVG(CASE WHEN duration_ms IS NOT NULL THEN duration_ms END) as avg_duration_ms,
    AVG(CASE WHEN memory_used_mb IS NOT NULL THEN memory_used_mb END) as avg_memory_mb
FROM invocations 
WHERE function_id = ? AND created_at >= ?
`

type GetInvocationStatsParams struct {
	FunctionID string       `db:"function_id" json:"function_id"`
	CreatedAt  sql.NullTime `db:"created_at" json:"created_at"`
}

type GetInvocationStatsRow struct {
	TotalInvocations      int64           `db:"total_invocations" json:"total_invocations"`
	SuccessfulInvocations int64           `db:"successful_invocations" json:"successful_invocations"`
	FailedInvocations     int64           `db:"failed_invocations" json:"failed_invocations"`
	AvgDurationMs         sql.NullFloat64 `db:"avg_duration_ms" json:"avg_duration_ms"`
	AvgMemoryMb           sql.NullFloat64 `db:"avg_memory_mb" json:"avg_memory_mb"`
}

func (q *Queries) GetInvocationStats(ctx context.Context, arg GetInvocationStatsParams) (GetInvocationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getInvocationStats, arg.FunctionID, arg.CreatedAt)
	var i GetInvocationStatsRow
	err := row.Scan(
		&i.TotalInvocations,
		&i.SuccessfulInvocations,
		&i.FailedInvocations,
		&i.AvgDurationMs,
		&i.AvgMemoryMb,
	)
	return i, err
}

const listInvocations = `-- name: ListInvocations :many
SELECT id, function_id, deployment_id, status, duration_ms, memory_used_mb, response_size_bytes, logs, error, created_at, completed_at FROM invocations ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListInvocationsParams struct {
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

func (q *Queries) ListInvocations(ctx context.Context, arg ListInvocationsParams) ([]Invocation, error) {
	rows, err := q.db.QueryContext(ctx, listInvocations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invocation{}
	for rows.Next() {
		var i Invocation
		if err := rows.Scan(
			&i.ID,
			&i.FunctionID,
			&i.DeploymentID,
			&i.Status,
			&i.DurationMs,
			&i.MemoryUsedMb,
			&i.ResponseSizeBytes,
			&i.Logs,
			&i.Error,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvocationsByFunction = `-- name: ListInvocationsByFunction :many
SELECT id, function_id, deployment_id, status, duration_ms, memory_used_mb, response_size_bytes, logs, error, created_at, completed_at FROM invocations 
WHERE function_id = ? 
ORDER BY created_at DESC 
LIMIT ? OFFSET ?
`

type ListInvocationsByFunctionParams struct {
	FunctionID string `db:"function_id" json:"function_id"`
	Limit      int64  `db:"limit" json:"limit"`
	Offset     int64  `db:"offset" json:"offset"`
}

func (q *Queries) ListInvocationsByFunction(ctx context.Context, arg ListInvocationsByFunctionParams) ([]Invocation, error) {
	rows, err := q.db.QueryContext(ctx, listInvocationsByFunction, arg.FunctionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invocation{}
	for rows.Next() {
		var i Invocation
		if err := rows.Scan(
			&i.ID,
			&i.FunctionID,
			&i.DeploymentID,
			&i.Status,
			&i.DurationMs,
			&i.MemoryUsedMb,
			&i.ResponseSizeBytes,
			&i.Logs,
			&i.Error,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvocationComplete = `-- name: UpdateInvocationComplete :one
UPDATE invocations 
SET 
    status = ?,
    duration_ms = ?,
    memory_used_mb = ?,
    response_size_bytes = ?,
    logs = ?,
    error = ?,
    completed_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, function_id, deployment_id, status, duration_ms, memory_used_mb, response_size_bytes, logs, error, created_at, completed_at
`

type UpdateInvocationCompleteParams struct {
	Status            string         `db:"status" json:"status"`
	DurationMs        sql.NullInt64  `db:"duration_ms" json:"duration_ms"`
	MemoryUsedMb      sql.NullInt64  `db:"memory_used_mb" json:"memory_used_mb"`
	ResponseSizeBytes sql.NullInt64  `db:"response_size_bytes" json:"response_size_bytes"`
	Logs              sql.NullString `db:"logs" json:"logs"`
	Error             sql.NullString `db:"error" json:"error"`
	ID                string         `db:"id" json:"id"`
}

func (q *Queries) UpdateInvocationComplete(ctx context.Context, arg UpdateInvocationCompleteParams) (Invocation, error) {
	row := q.db.QueryRowContext(ctx, updateInvocationComplete,
		arg.Status,
		arg.DurationMs,
		arg.MemoryUsedMb,
		arg.ResponseSizeBytes,
		arg.Logs,
		arg.Error,
		arg.ID,
	)
	var i Invocation
	err := row.Scan(
		&i.ID,
		&i.FunctionID,
		&i.DeploymentID,
		&i.Status,
		&i.DurationMs,
		&i.MemoryUsedMb,
		&i.ResponseSizeBytes,
		&i.Logs,
		&i.Error,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}
